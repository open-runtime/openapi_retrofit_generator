// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'class_with_nullable_types.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$ClassWithNullableTypes {

 String get p1; List<String> get p2;@JsonKey(name: 'p2_null_item') List<List<String?>> get p2NullItem;@JsonKey(name: 'p2_null_all') List<dynamic>? get p2NullAll;@JsonKey(name: 'ClassWithNullableTypesP3') ClassWithNullableTypesP3 get classWithNullableTypesP3;@JsonKey(name: 'required_null_anyOf') String get requiredNullAnyOf;@JsonKey(name: 'p1_anyOf') String get p1AnyOf;@JsonKey(name: 'p2_anyOf') dynamic get p2AnyOf;@JsonKey(name: 'p3_anyOf') dynamic get p3AnyOf;@JsonKey(name: 'p1_oneOf') String get p1OneOf;@JsonKey(name: 'p2_oneOf') dynamic get p2OneOf;@JsonKey(name: 'p3_oneOf') dynamic get p3OneOf;@JsonKey(name: 'p1_allOf') dynamic get p1AllOf;@JsonKey(name: 'p2_allOf') dynamic get p2AllOf;@JsonKey(name: 'p3_allOf') dynamic get p3AllOf;@JsonKey(name: 'valid_int') int? get validInt;@JsonKey(name: 'valid_string') String? get validString;@JsonKey(name: 'valid_array') List<String>? get validArray;@JsonKey(name: 'p2_null') List<dynamic>? get p2Null;@JsonKey(name: 'p1_n') String? get p1N;@JsonKey(name: 'p2_n') List<String?>? get p2N;@JsonKey(name: 'ClassWithNullableTypesP3N') ClassWithNullableTypesP3N? get classWithNullableTypesP3N;@JsonKey(name: 'p1_list') String? get p1List;@JsonKey(name: 'p2_list') List<dynamic>? get p2List;@JsonKey(name: 'p3_list') dynamic get p3List;@JsonKey(name: 'nonNull_anyOf') ClassWithNullableTypesNonNullAnyOfUnion? get nonNullAnyOf;@JsonKey(name: 'optional_null_anyOf') String? get optionalNullAnyOf;
/// Create a copy of ClassWithNullableTypes
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ClassWithNullableTypesCopyWith<ClassWithNullableTypes> get copyWith => _$ClassWithNullableTypesCopyWithImpl<ClassWithNullableTypes>(this as ClassWithNullableTypes, _$identity);

  /// Serializes this ClassWithNullableTypes to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ClassWithNullableTypes&&(identical(other.p1, p1) || other.p1 == p1)&&const DeepCollectionEquality().equals(other.p2, p2)&&const DeepCollectionEquality().equals(other.p2NullItem, p2NullItem)&&const DeepCollectionEquality().equals(other.p2NullAll, p2NullAll)&&(identical(other.classWithNullableTypesP3, classWithNullableTypesP3) || other.classWithNullableTypesP3 == classWithNullableTypesP3)&&(identical(other.requiredNullAnyOf, requiredNullAnyOf) || other.requiredNullAnyOf == requiredNullAnyOf)&&(identical(other.p1AnyOf, p1AnyOf) || other.p1AnyOf == p1AnyOf)&&const DeepCollectionEquality().equals(other.p2AnyOf, p2AnyOf)&&const DeepCollectionEquality().equals(other.p3AnyOf, p3AnyOf)&&(identical(other.p1OneOf, p1OneOf) || other.p1OneOf == p1OneOf)&&const DeepCollectionEquality().equals(other.p2OneOf, p2OneOf)&&const DeepCollectionEquality().equals(other.p3OneOf, p3OneOf)&&const DeepCollectionEquality().equals(other.p1AllOf, p1AllOf)&&const DeepCollectionEquality().equals(other.p2AllOf, p2AllOf)&&const DeepCollectionEquality().equals(other.p3AllOf, p3AllOf)&&(identical(other.validInt, validInt) || other.validInt == validInt)&&(identical(other.validString, validString) || other.validString == validString)&&const DeepCollectionEquality().equals(other.validArray, validArray)&&const DeepCollectionEquality().equals(other.p2Null, p2Null)&&(identical(other.p1N, p1N) || other.p1N == p1N)&&const DeepCollectionEquality().equals(other.p2N, p2N)&&(identical(other.classWithNullableTypesP3N, classWithNullableTypesP3N) || other.classWithNullableTypesP3N == classWithNullableTypesP3N)&&(identical(other.p1List, p1List) || other.p1List == p1List)&&const DeepCollectionEquality().equals(other.p2List, p2List)&&const DeepCollectionEquality().equals(other.p3List, p3List)&&(identical(other.nonNullAnyOf, nonNullAnyOf) || other.nonNullAnyOf == nonNullAnyOf)&&(identical(other.optionalNullAnyOf, optionalNullAnyOf) || other.optionalNullAnyOf == optionalNullAnyOf));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hashAll([runtimeType,p1,const DeepCollectionEquality().hash(p2),const DeepCollectionEquality().hash(p2NullItem),const DeepCollectionEquality().hash(p2NullAll),classWithNullableTypesP3,requiredNullAnyOf,p1AnyOf,const DeepCollectionEquality().hash(p2AnyOf),const DeepCollectionEquality().hash(p3AnyOf),p1OneOf,const DeepCollectionEquality().hash(p2OneOf),const DeepCollectionEquality().hash(p3OneOf),const DeepCollectionEquality().hash(p1AllOf),const DeepCollectionEquality().hash(p2AllOf),const DeepCollectionEquality().hash(p3AllOf),validInt,validString,const DeepCollectionEquality().hash(validArray),const DeepCollectionEquality().hash(p2Null),p1N,const DeepCollectionEquality().hash(p2N),classWithNullableTypesP3N,p1List,const DeepCollectionEquality().hash(p2List),const DeepCollectionEquality().hash(p3List),nonNullAnyOf,optionalNullAnyOf]);

@override
String toString() {
  return 'ClassWithNullableTypes(p1: $p1, p2: $p2, p2NullItem: $p2NullItem, p2NullAll: $p2NullAll, classWithNullableTypesP3: $classWithNullableTypesP3, requiredNullAnyOf: $requiredNullAnyOf, p1AnyOf: $p1AnyOf, p2AnyOf: $p2AnyOf, p3AnyOf: $p3AnyOf, p1OneOf: $p1OneOf, p2OneOf: $p2OneOf, p3OneOf: $p3OneOf, p1AllOf: $p1AllOf, p2AllOf: $p2AllOf, p3AllOf: $p3AllOf, validInt: $validInt, validString: $validString, validArray: $validArray, p2Null: $p2Null, p1N: $p1N, p2N: $p2N, classWithNullableTypesP3N: $classWithNullableTypesP3N, p1List: $p1List, p2List: $p2List, p3List: $p3List, nonNullAnyOf: $nonNullAnyOf, optionalNullAnyOf: $optionalNullAnyOf)';
}


}

/// @nodoc
abstract mixin class $ClassWithNullableTypesCopyWith<$Res>  {
  factory $ClassWithNullableTypesCopyWith(ClassWithNullableTypes value, $Res Function(ClassWithNullableTypes) _then) = _$ClassWithNullableTypesCopyWithImpl;
@useResult
$Res call({
 String p1, List<String> p2,@JsonKey(name: 'p2_null_item') List<List<String?>> p2NullItem,@JsonKey(name: 'p2_null_all') List<dynamic>? p2NullAll,@JsonKey(name: 'ClassWithNullableTypesP3') ClassWithNullableTypesP3 classWithNullableTypesP3,@JsonKey(name: 'required_null_anyOf') String requiredNullAnyOf,@JsonKey(name: 'p1_anyOf') String p1AnyOf,@JsonKey(name: 'p2_anyOf') dynamic p2AnyOf,@JsonKey(name: 'p3_anyOf') dynamic p3AnyOf,@JsonKey(name: 'p1_oneOf') String p1OneOf,@JsonKey(name: 'p2_oneOf') dynamic p2OneOf,@JsonKey(name: 'p3_oneOf') dynamic p3OneOf,@JsonKey(name: 'p1_allOf') dynamic p1AllOf,@JsonKey(name: 'p2_allOf') dynamic p2AllOf,@JsonKey(name: 'p3_allOf') dynamic p3AllOf,@JsonKey(name: 'valid_int') int? validInt,@JsonKey(name: 'valid_string') String? validString,@JsonKey(name: 'valid_array') List<String>? validArray,@JsonKey(name: 'p2_null') List<dynamic>? p2Null,@JsonKey(name: 'p1_n') String? p1N,@JsonKey(name: 'p2_n') List<String?>? p2N,@JsonKey(name: 'ClassWithNullableTypesP3N') ClassWithNullableTypesP3N? classWithNullableTypesP3N,@JsonKey(name: 'p1_list') String? p1List,@JsonKey(name: 'p2_list') List<dynamic>? p2List,@JsonKey(name: 'p3_list') dynamic p3List,@JsonKey(name: 'nonNull_anyOf') ClassWithNullableTypesNonNullAnyOfUnion? nonNullAnyOf,@JsonKey(name: 'optional_null_anyOf') String? optionalNullAnyOf
});


$ClassWithNullableTypesP3CopyWith<$Res> get classWithNullableTypesP3;$ClassWithNullableTypesP3NCopyWith<$Res>? get classWithNullableTypesP3N;

}
/// @nodoc
class _$ClassWithNullableTypesCopyWithImpl<$Res>
    implements $ClassWithNullableTypesCopyWith<$Res> {
  _$ClassWithNullableTypesCopyWithImpl(this._self, this._then);

  final ClassWithNullableTypes _self;
  final $Res Function(ClassWithNullableTypes) _then;

/// Create a copy of ClassWithNullableTypes
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? p1 = null,Object? p2 = null,Object? p2NullItem = null,Object? p2NullAll = freezed,Object? classWithNullableTypesP3 = null,Object? requiredNullAnyOf = null,Object? p1AnyOf = null,Object? p2AnyOf = freezed,Object? p3AnyOf = freezed,Object? p1OneOf = null,Object? p2OneOf = freezed,Object? p3OneOf = freezed,Object? p1AllOf = freezed,Object? p2AllOf = freezed,Object? p3AllOf = freezed,Object? validInt = freezed,Object? validString = freezed,Object? validArray = freezed,Object? p2Null = freezed,Object? p1N = freezed,Object? p2N = freezed,Object? classWithNullableTypesP3N = freezed,Object? p1List = freezed,Object? p2List = freezed,Object? p3List = freezed,Object? nonNullAnyOf = freezed,Object? optionalNullAnyOf = freezed,}) {
  return _then(_self.copyWith(
p1: null == p1 ? _self.p1 : p1 // ignore: cast_nullable_to_non_nullable
as String,p2: null == p2 ? _self.p2 : p2 // ignore: cast_nullable_to_non_nullable
as List<String>,p2NullItem: null == p2NullItem ? _self.p2NullItem : p2NullItem // ignore: cast_nullable_to_non_nullable
as List<List<String?>>,p2NullAll: freezed == p2NullAll ? _self.p2NullAll : p2NullAll // ignore: cast_nullable_to_non_nullable
as List<dynamic>?,classWithNullableTypesP3: null == classWithNullableTypesP3 ? _self.classWithNullableTypesP3 : classWithNullableTypesP3 // ignore: cast_nullable_to_non_nullable
as ClassWithNullableTypesP3,requiredNullAnyOf: null == requiredNullAnyOf ? _self.requiredNullAnyOf : requiredNullAnyOf // ignore: cast_nullable_to_non_nullable
as String,p1AnyOf: null == p1AnyOf ? _self.p1AnyOf : p1AnyOf // ignore: cast_nullable_to_non_nullable
as String,p2AnyOf: freezed == p2AnyOf ? _self.p2AnyOf : p2AnyOf // ignore: cast_nullable_to_non_nullable
as dynamic,p3AnyOf: freezed == p3AnyOf ? _self.p3AnyOf : p3AnyOf // ignore: cast_nullable_to_non_nullable
as dynamic,p1OneOf: null == p1OneOf ? _self.p1OneOf : p1OneOf // ignore: cast_nullable_to_non_nullable
as String,p2OneOf: freezed == p2OneOf ? _self.p2OneOf : p2OneOf // ignore: cast_nullable_to_non_nullable
as dynamic,p3OneOf: freezed == p3OneOf ? _self.p3OneOf : p3OneOf // ignore: cast_nullable_to_non_nullable
as dynamic,p1AllOf: freezed == p1AllOf ? _self.p1AllOf : p1AllOf // ignore: cast_nullable_to_non_nullable
as dynamic,p2AllOf: freezed == p2AllOf ? _self.p2AllOf : p2AllOf // ignore: cast_nullable_to_non_nullable
as dynamic,p3AllOf: freezed == p3AllOf ? _self.p3AllOf : p3AllOf // ignore: cast_nullable_to_non_nullable
as dynamic,validInt: freezed == validInt ? _self.validInt : validInt // ignore: cast_nullable_to_non_nullable
as int?,validString: freezed == validString ? _self.validString : validString // ignore: cast_nullable_to_non_nullable
as String?,validArray: freezed == validArray ? _self.validArray : validArray // ignore: cast_nullable_to_non_nullable
as List<String>?,p2Null: freezed == p2Null ? _self.p2Null : p2Null // ignore: cast_nullable_to_non_nullable
as List<dynamic>?,p1N: freezed == p1N ? _self.p1N : p1N // ignore: cast_nullable_to_non_nullable
as String?,p2N: freezed == p2N ? _self.p2N : p2N // ignore: cast_nullable_to_non_nullable
as List<String?>?,classWithNullableTypesP3N: freezed == classWithNullableTypesP3N ? _self.classWithNullableTypesP3N : classWithNullableTypesP3N // ignore: cast_nullable_to_non_nullable
as ClassWithNullableTypesP3N?,p1List: freezed == p1List ? _self.p1List : p1List // ignore: cast_nullable_to_non_nullable
as String?,p2List: freezed == p2List ? _self.p2List : p2List // ignore: cast_nullable_to_non_nullable
as List<dynamic>?,p3List: freezed == p3List ? _self.p3List : p3List // ignore: cast_nullable_to_non_nullable
as dynamic,nonNullAnyOf: freezed == nonNullAnyOf ? _self.nonNullAnyOf : nonNullAnyOf // ignore: cast_nullable_to_non_nullable
as ClassWithNullableTypesNonNullAnyOfUnion?,optionalNullAnyOf: freezed == optionalNullAnyOf ? _self.optionalNullAnyOf : optionalNullAnyOf // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}
/// Create a copy of ClassWithNullableTypes
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ClassWithNullableTypesP3CopyWith<$Res> get classWithNullableTypesP3 {
  
  return $ClassWithNullableTypesP3CopyWith<$Res>(_self.classWithNullableTypesP3, (value) {
    return _then(_self.copyWith(classWithNullableTypesP3: value));
  });
}/// Create a copy of ClassWithNullableTypes
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ClassWithNullableTypesP3NCopyWith<$Res>? get classWithNullableTypesP3N {
    if (_self.classWithNullableTypesP3N == null) {
    return null;
  }

  return $ClassWithNullableTypesP3NCopyWith<$Res>(_self.classWithNullableTypesP3N!, (value) {
    return _then(_self.copyWith(classWithNullableTypesP3N: value));
  });
}
}


/// Adds pattern-matching-related methods to [ClassWithNullableTypes].
extension ClassWithNullableTypesPatterns on ClassWithNullableTypes {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _ClassWithNullableTypes value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _ClassWithNullableTypes() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _ClassWithNullableTypes value)  $default,){
final _that = this;
switch (_that) {
case _ClassWithNullableTypes():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _ClassWithNullableTypes value)?  $default,){
final _that = this;
switch (_that) {
case _ClassWithNullableTypes() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( String p1,  List<String> p2, @JsonKey(name: 'p2_null_item')  List<List<String?>> p2NullItem, @JsonKey(name: 'p2_null_all')  List<dynamic>? p2NullAll, @JsonKey(name: 'ClassWithNullableTypesP3')  ClassWithNullableTypesP3 classWithNullableTypesP3, @JsonKey(name: 'required_null_anyOf')  String requiredNullAnyOf, @JsonKey(name: 'p1_anyOf')  String p1AnyOf, @JsonKey(name: 'p2_anyOf')  dynamic p2AnyOf, @JsonKey(name: 'p3_anyOf')  dynamic p3AnyOf, @JsonKey(name: 'p1_oneOf')  String p1OneOf, @JsonKey(name: 'p2_oneOf')  dynamic p2OneOf, @JsonKey(name: 'p3_oneOf')  dynamic p3OneOf, @JsonKey(name: 'p1_allOf')  dynamic p1AllOf, @JsonKey(name: 'p2_allOf')  dynamic p2AllOf, @JsonKey(name: 'p3_allOf')  dynamic p3AllOf, @JsonKey(name: 'valid_int')  int? validInt, @JsonKey(name: 'valid_string')  String? validString, @JsonKey(name: 'valid_array')  List<String>? validArray, @JsonKey(name: 'p2_null')  List<dynamic>? p2Null, @JsonKey(name: 'p1_n')  String? p1N, @JsonKey(name: 'p2_n')  List<String?>? p2N, @JsonKey(name: 'ClassWithNullableTypesP3N')  ClassWithNullableTypesP3N? classWithNullableTypesP3N, @JsonKey(name: 'p1_list')  String? p1List, @JsonKey(name: 'p2_list')  List<dynamic>? p2List, @JsonKey(name: 'p3_list')  dynamic p3List, @JsonKey(name: 'nonNull_anyOf')  ClassWithNullableTypesNonNullAnyOfUnion? nonNullAnyOf, @JsonKey(name: 'optional_null_anyOf')  String? optionalNullAnyOf)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _ClassWithNullableTypes() when $default != null:
return $default(_that.p1,_that.p2,_that.p2NullItem,_that.p2NullAll,_that.classWithNullableTypesP3,_that.requiredNullAnyOf,_that.p1AnyOf,_that.p2AnyOf,_that.p3AnyOf,_that.p1OneOf,_that.p2OneOf,_that.p3OneOf,_that.p1AllOf,_that.p2AllOf,_that.p3AllOf,_that.validInt,_that.validString,_that.validArray,_that.p2Null,_that.p1N,_that.p2N,_that.classWithNullableTypesP3N,_that.p1List,_that.p2List,_that.p3List,_that.nonNullAnyOf,_that.optionalNullAnyOf);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( String p1,  List<String> p2, @JsonKey(name: 'p2_null_item')  List<List<String?>> p2NullItem, @JsonKey(name: 'p2_null_all')  List<dynamic>? p2NullAll, @JsonKey(name: 'ClassWithNullableTypesP3')  ClassWithNullableTypesP3 classWithNullableTypesP3, @JsonKey(name: 'required_null_anyOf')  String requiredNullAnyOf, @JsonKey(name: 'p1_anyOf')  String p1AnyOf, @JsonKey(name: 'p2_anyOf')  dynamic p2AnyOf, @JsonKey(name: 'p3_anyOf')  dynamic p3AnyOf, @JsonKey(name: 'p1_oneOf')  String p1OneOf, @JsonKey(name: 'p2_oneOf')  dynamic p2OneOf, @JsonKey(name: 'p3_oneOf')  dynamic p3OneOf, @JsonKey(name: 'p1_allOf')  dynamic p1AllOf, @JsonKey(name: 'p2_allOf')  dynamic p2AllOf, @JsonKey(name: 'p3_allOf')  dynamic p3AllOf, @JsonKey(name: 'valid_int')  int? validInt, @JsonKey(name: 'valid_string')  String? validString, @JsonKey(name: 'valid_array')  List<String>? validArray, @JsonKey(name: 'p2_null')  List<dynamic>? p2Null, @JsonKey(name: 'p1_n')  String? p1N, @JsonKey(name: 'p2_n')  List<String?>? p2N, @JsonKey(name: 'ClassWithNullableTypesP3N')  ClassWithNullableTypesP3N? classWithNullableTypesP3N, @JsonKey(name: 'p1_list')  String? p1List, @JsonKey(name: 'p2_list')  List<dynamic>? p2List, @JsonKey(name: 'p3_list')  dynamic p3List, @JsonKey(name: 'nonNull_anyOf')  ClassWithNullableTypesNonNullAnyOfUnion? nonNullAnyOf, @JsonKey(name: 'optional_null_anyOf')  String? optionalNullAnyOf)  $default,) {final _that = this;
switch (_that) {
case _ClassWithNullableTypes():
return $default(_that.p1,_that.p2,_that.p2NullItem,_that.p2NullAll,_that.classWithNullableTypesP3,_that.requiredNullAnyOf,_that.p1AnyOf,_that.p2AnyOf,_that.p3AnyOf,_that.p1OneOf,_that.p2OneOf,_that.p3OneOf,_that.p1AllOf,_that.p2AllOf,_that.p3AllOf,_that.validInt,_that.validString,_that.validArray,_that.p2Null,_that.p1N,_that.p2N,_that.classWithNullableTypesP3N,_that.p1List,_that.p2List,_that.p3List,_that.nonNullAnyOf,_that.optionalNullAnyOf);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( String p1,  List<String> p2, @JsonKey(name: 'p2_null_item')  List<List<String?>> p2NullItem, @JsonKey(name: 'p2_null_all')  List<dynamic>? p2NullAll, @JsonKey(name: 'ClassWithNullableTypesP3')  ClassWithNullableTypesP3 classWithNullableTypesP3, @JsonKey(name: 'required_null_anyOf')  String requiredNullAnyOf, @JsonKey(name: 'p1_anyOf')  String p1AnyOf, @JsonKey(name: 'p2_anyOf')  dynamic p2AnyOf, @JsonKey(name: 'p3_anyOf')  dynamic p3AnyOf, @JsonKey(name: 'p1_oneOf')  String p1OneOf, @JsonKey(name: 'p2_oneOf')  dynamic p2OneOf, @JsonKey(name: 'p3_oneOf')  dynamic p3OneOf, @JsonKey(name: 'p1_allOf')  dynamic p1AllOf, @JsonKey(name: 'p2_allOf')  dynamic p2AllOf, @JsonKey(name: 'p3_allOf')  dynamic p3AllOf, @JsonKey(name: 'valid_int')  int? validInt, @JsonKey(name: 'valid_string')  String? validString, @JsonKey(name: 'valid_array')  List<String>? validArray, @JsonKey(name: 'p2_null')  List<dynamic>? p2Null, @JsonKey(name: 'p1_n')  String? p1N, @JsonKey(name: 'p2_n')  List<String?>? p2N, @JsonKey(name: 'ClassWithNullableTypesP3N')  ClassWithNullableTypesP3N? classWithNullableTypesP3N, @JsonKey(name: 'p1_list')  String? p1List, @JsonKey(name: 'p2_list')  List<dynamic>? p2List, @JsonKey(name: 'p3_list')  dynamic p3List, @JsonKey(name: 'nonNull_anyOf')  ClassWithNullableTypesNonNullAnyOfUnion? nonNullAnyOf, @JsonKey(name: 'optional_null_anyOf')  String? optionalNullAnyOf)?  $default,) {final _that = this;
switch (_that) {
case _ClassWithNullableTypes() when $default != null:
return $default(_that.p1,_that.p2,_that.p2NullItem,_that.p2NullAll,_that.classWithNullableTypesP3,_that.requiredNullAnyOf,_that.p1AnyOf,_that.p2AnyOf,_that.p3AnyOf,_that.p1OneOf,_that.p2OneOf,_that.p3OneOf,_that.p1AllOf,_that.p2AllOf,_that.p3AllOf,_that.validInt,_that.validString,_that.validArray,_that.p2Null,_that.p1N,_that.p2N,_that.classWithNullableTypesP3N,_that.p1List,_that.p2List,_that.p3List,_that.nonNullAnyOf,_that.optionalNullAnyOf);case _:
  return null;

}
}

}

/// @nodoc
@JsonSerializable()

class _ClassWithNullableTypes implements ClassWithNullableTypes {
  const _ClassWithNullableTypes({required this.p1, required final  List<String> p2, @JsonKey(name: 'p2_null_item') required final  List<List<String?>> p2NullItem, @JsonKey(name: 'p2_null_all') required final  List<dynamic>? p2NullAll, @JsonKey(name: 'ClassWithNullableTypesP3') required this.classWithNullableTypesP3, @JsonKey(name: 'required_null_anyOf') required this.requiredNullAnyOf, @JsonKey(name: 'p1_anyOf') required this.p1AnyOf, @JsonKey(name: 'p2_anyOf') required this.p2AnyOf, @JsonKey(name: 'p3_anyOf') required this.p3AnyOf, @JsonKey(name: 'p1_oneOf') required this.p1OneOf, @JsonKey(name: 'p2_oneOf') required this.p2OneOf, @JsonKey(name: 'p3_oneOf') required this.p3OneOf, @JsonKey(name: 'p1_allOf') required this.p1AllOf, @JsonKey(name: 'p2_allOf') required this.p2AllOf, @JsonKey(name: 'p3_allOf') required this.p3AllOf, @JsonKey(name: 'valid_int') this.validInt, @JsonKey(name: 'valid_string') this.validString, @JsonKey(name: 'valid_array') final  List<String>? validArray, @JsonKey(name: 'p2_null') final  List<dynamic>? p2Null, @JsonKey(name: 'p1_n') this.p1N, @JsonKey(name: 'p2_n') final  List<String?>? p2N, @JsonKey(name: 'ClassWithNullableTypesP3N') this.classWithNullableTypesP3N, @JsonKey(name: 'p1_list') this.p1List, @JsonKey(name: 'p2_list') final  List<dynamic>? p2List, @JsonKey(name: 'p3_list') this.p3List, @JsonKey(name: 'nonNull_anyOf') this.nonNullAnyOf, @JsonKey(name: 'optional_null_anyOf') this.optionalNullAnyOf}): _p2 = p2,_p2NullItem = p2NullItem,_p2NullAll = p2NullAll,_validArray = validArray,_p2Null = p2Null,_p2N = p2N,_p2List = p2List;
  factory _ClassWithNullableTypes.fromJson(Map<String, dynamic> json) => _$ClassWithNullableTypesFromJson(json);

@override final  String p1;
 final  List<String> _p2;
@override List<String> get p2 {
  if (_p2 is EqualUnmodifiableListView) return _p2;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_p2);
}

 final  List<List<String?>> _p2NullItem;
@override@JsonKey(name: 'p2_null_item') List<List<String?>> get p2NullItem {
  if (_p2NullItem is EqualUnmodifiableListView) return _p2NullItem;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_p2NullItem);
}

 final  List<dynamic>? _p2NullAll;
@override@JsonKey(name: 'p2_null_all') List<dynamic>? get p2NullAll {
  final value = _p2NullAll;
  if (value == null) return null;
  if (_p2NullAll is EqualUnmodifiableListView) return _p2NullAll;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

@override@JsonKey(name: 'ClassWithNullableTypesP3') final  ClassWithNullableTypesP3 classWithNullableTypesP3;
@override@JsonKey(name: 'required_null_anyOf') final  String requiredNullAnyOf;
@override@JsonKey(name: 'p1_anyOf') final  String p1AnyOf;
@override@JsonKey(name: 'p2_anyOf') final  dynamic p2AnyOf;
@override@JsonKey(name: 'p3_anyOf') final  dynamic p3AnyOf;
@override@JsonKey(name: 'p1_oneOf') final  String p1OneOf;
@override@JsonKey(name: 'p2_oneOf') final  dynamic p2OneOf;
@override@JsonKey(name: 'p3_oneOf') final  dynamic p3OneOf;
@override@JsonKey(name: 'p1_allOf') final  dynamic p1AllOf;
@override@JsonKey(name: 'p2_allOf') final  dynamic p2AllOf;
@override@JsonKey(name: 'p3_allOf') final  dynamic p3AllOf;
@override@JsonKey(name: 'valid_int') final  int? validInt;
@override@JsonKey(name: 'valid_string') final  String? validString;
 final  List<String>? _validArray;
@override@JsonKey(name: 'valid_array') List<String>? get validArray {
  final value = _validArray;
  if (value == null) return null;
  if (_validArray is EqualUnmodifiableListView) return _validArray;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

 final  List<dynamic>? _p2Null;
@override@JsonKey(name: 'p2_null') List<dynamic>? get p2Null {
  final value = _p2Null;
  if (value == null) return null;
  if (_p2Null is EqualUnmodifiableListView) return _p2Null;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

@override@JsonKey(name: 'p1_n') final  String? p1N;
 final  List<String?>? _p2N;
@override@JsonKey(name: 'p2_n') List<String?>? get p2N {
  final value = _p2N;
  if (value == null) return null;
  if (_p2N is EqualUnmodifiableListView) return _p2N;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

@override@JsonKey(name: 'ClassWithNullableTypesP3N') final  ClassWithNullableTypesP3N? classWithNullableTypesP3N;
@override@JsonKey(name: 'p1_list') final  String? p1List;
 final  List<dynamic>? _p2List;
@override@JsonKey(name: 'p2_list') List<dynamic>? get p2List {
  final value = _p2List;
  if (value == null) return null;
  if (_p2List is EqualUnmodifiableListView) return _p2List;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

@override@JsonKey(name: 'p3_list') final  dynamic p3List;
@override@JsonKey(name: 'nonNull_anyOf') final  ClassWithNullableTypesNonNullAnyOfUnion? nonNullAnyOf;
@override@JsonKey(name: 'optional_null_anyOf') final  String? optionalNullAnyOf;

/// Create a copy of ClassWithNullableTypes
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ClassWithNullableTypesCopyWith<_ClassWithNullableTypes> get copyWith => __$ClassWithNullableTypesCopyWithImpl<_ClassWithNullableTypes>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ClassWithNullableTypesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ClassWithNullableTypes&&(identical(other.p1, p1) || other.p1 == p1)&&const DeepCollectionEquality().equals(other._p2, _p2)&&const DeepCollectionEquality().equals(other._p2NullItem, _p2NullItem)&&const DeepCollectionEquality().equals(other._p2NullAll, _p2NullAll)&&(identical(other.classWithNullableTypesP3, classWithNullableTypesP3) || other.classWithNullableTypesP3 == classWithNullableTypesP3)&&(identical(other.requiredNullAnyOf, requiredNullAnyOf) || other.requiredNullAnyOf == requiredNullAnyOf)&&(identical(other.p1AnyOf, p1AnyOf) || other.p1AnyOf == p1AnyOf)&&const DeepCollectionEquality().equals(other.p2AnyOf, p2AnyOf)&&const DeepCollectionEquality().equals(other.p3AnyOf, p3AnyOf)&&(identical(other.p1OneOf, p1OneOf) || other.p1OneOf == p1OneOf)&&const DeepCollectionEquality().equals(other.p2OneOf, p2OneOf)&&const DeepCollectionEquality().equals(other.p3OneOf, p3OneOf)&&const DeepCollectionEquality().equals(other.p1AllOf, p1AllOf)&&const DeepCollectionEquality().equals(other.p2AllOf, p2AllOf)&&const DeepCollectionEquality().equals(other.p3AllOf, p3AllOf)&&(identical(other.validInt, validInt) || other.validInt == validInt)&&(identical(other.validString, validString) || other.validString == validString)&&const DeepCollectionEquality().equals(other._validArray, _validArray)&&const DeepCollectionEquality().equals(other._p2Null, _p2Null)&&(identical(other.p1N, p1N) || other.p1N == p1N)&&const DeepCollectionEquality().equals(other._p2N, _p2N)&&(identical(other.classWithNullableTypesP3N, classWithNullableTypesP3N) || other.classWithNullableTypesP3N == classWithNullableTypesP3N)&&(identical(other.p1List, p1List) || other.p1List == p1List)&&const DeepCollectionEquality().equals(other._p2List, _p2List)&&const DeepCollectionEquality().equals(other.p3List, p3List)&&(identical(other.nonNullAnyOf, nonNullAnyOf) || other.nonNullAnyOf == nonNullAnyOf)&&(identical(other.optionalNullAnyOf, optionalNullAnyOf) || other.optionalNullAnyOf == optionalNullAnyOf));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hashAll([runtimeType,p1,const DeepCollectionEquality().hash(_p2),const DeepCollectionEquality().hash(_p2NullItem),const DeepCollectionEquality().hash(_p2NullAll),classWithNullableTypesP3,requiredNullAnyOf,p1AnyOf,const DeepCollectionEquality().hash(p2AnyOf),const DeepCollectionEquality().hash(p3AnyOf),p1OneOf,const DeepCollectionEquality().hash(p2OneOf),const DeepCollectionEquality().hash(p3OneOf),const DeepCollectionEquality().hash(p1AllOf),const DeepCollectionEquality().hash(p2AllOf),const DeepCollectionEquality().hash(p3AllOf),validInt,validString,const DeepCollectionEquality().hash(_validArray),const DeepCollectionEquality().hash(_p2Null),p1N,const DeepCollectionEquality().hash(_p2N),classWithNullableTypesP3N,p1List,const DeepCollectionEquality().hash(_p2List),const DeepCollectionEquality().hash(p3List),nonNullAnyOf,optionalNullAnyOf]);

@override
String toString() {
  return 'ClassWithNullableTypes(p1: $p1, p2: $p2, p2NullItem: $p2NullItem, p2NullAll: $p2NullAll, classWithNullableTypesP3: $classWithNullableTypesP3, requiredNullAnyOf: $requiredNullAnyOf, p1AnyOf: $p1AnyOf, p2AnyOf: $p2AnyOf, p3AnyOf: $p3AnyOf, p1OneOf: $p1OneOf, p2OneOf: $p2OneOf, p3OneOf: $p3OneOf, p1AllOf: $p1AllOf, p2AllOf: $p2AllOf, p3AllOf: $p3AllOf, validInt: $validInt, validString: $validString, validArray: $validArray, p2Null: $p2Null, p1N: $p1N, p2N: $p2N, classWithNullableTypesP3N: $classWithNullableTypesP3N, p1List: $p1List, p2List: $p2List, p3List: $p3List, nonNullAnyOf: $nonNullAnyOf, optionalNullAnyOf: $optionalNullAnyOf)';
}


}

/// @nodoc
abstract mixin class _$ClassWithNullableTypesCopyWith<$Res> implements $ClassWithNullableTypesCopyWith<$Res> {
  factory _$ClassWithNullableTypesCopyWith(_ClassWithNullableTypes value, $Res Function(_ClassWithNullableTypes) _then) = __$ClassWithNullableTypesCopyWithImpl;
@override @useResult
$Res call({
 String p1, List<String> p2,@JsonKey(name: 'p2_null_item') List<List<String?>> p2NullItem,@JsonKey(name: 'p2_null_all') List<dynamic>? p2NullAll,@JsonKey(name: 'ClassWithNullableTypesP3') ClassWithNullableTypesP3 classWithNullableTypesP3,@JsonKey(name: 'required_null_anyOf') String requiredNullAnyOf,@JsonKey(name: 'p1_anyOf') String p1AnyOf,@JsonKey(name: 'p2_anyOf') dynamic p2AnyOf,@JsonKey(name: 'p3_anyOf') dynamic p3AnyOf,@JsonKey(name: 'p1_oneOf') String p1OneOf,@JsonKey(name: 'p2_oneOf') dynamic p2OneOf,@JsonKey(name: 'p3_oneOf') dynamic p3OneOf,@JsonKey(name: 'p1_allOf') dynamic p1AllOf,@JsonKey(name: 'p2_allOf') dynamic p2AllOf,@JsonKey(name: 'p3_allOf') dynamic p3AllOf,@JsonKey(name: 'valid_int') int? validInt,@JsonKey(name: 'valid_string') String? validString,@JsonKey(name: 'valid_array') List<String>? validArray,@JsonKey(name: 'p2_null') List<dynamic>? p2Null,@JsonKey(name: 'p1_n') String? p1N,@JsonKey(name: 'p2_n') List<String?>? p2N,@JsonKey(name: 'ClassWithNullableTypesP3N') ClassWithNullableTypesP3N? classWithNullableTypesP3N,@JsonKey(name: 'p1_list') String? p1List,@JsonKey(name: 'p2_list') List<dynamic>? p2List,@JsonKey(name: 'p3_list') dynamic p3List,@JsonKey(name: 'nonNull_anyOf') ClassWithNullableTypesNonNullAnyOfUnion? nonNullAnyOf,@JsonKey(name: 'optional_null_anyOf') String? optionalNullAnyOf
});


@override $ClassWithNullableTypesP3CopyWith<$Res> get classWithNullableTypesP3;@override $ClassWithNullableTypesP3NCopyWith<$Res>? get classWithNullableTypesP3N;

}
/// @nodoc
class __$ClassWithNullableTypesCopyWithImpl<$Res>
    implements _$ClassWithNullableTypesCopyWith<$Res> {
  __$ClassWithNullableTypesCopyWithImpl(this._self, this._then);

  final _ClassWithNullableTypes _self;
  final $Res Function(_ClassWithNullableTypes) _then;

/// Create a copy of ClassWithNullableTypes
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? p1 = null,Object? p2 = null,Object? p2NullItem = null,Object? p2NullAll = freezed,Object? classWithNullableTypesP3 = null,Object? requiredNullAnyOf = null,Object? p1AnyOf = null,Object? p2AnyOf = freezed,Object? p3AnyOf = freezed,Object? p1OneOf = null,Object? p2OneOf = freezed,Object? p3OneOf = freezed,Object? p1AllOf = freezed,Object? p2AllOf = freezed,Object? p3AllOf = freezed,Object? validInt = freezed,Object? validString = freezed,Object? validArray = freezed,Object? p2Null = freezed,Object? p1N = freezed,Object? p2N = freezed,Object? classWithNullableTypesP3N = freezed,Object? p1List = freezed,Object? p2List = freezed,Object? p3List = freezed,Object? nonNullAnyOf = freezed,Object? optionalNullAnyOf = freezed,}) {
  return _then(_ClassWithNullableTypes(
p1: null == p1 ? _self.p1 : p1 // ignore: cast_nullable_to_non_nullable
as String,p2: null == p2 ? _self._p2 : p2 // ignore: cast_nullable_to_non_nullable
as List<String>,p2NullItem: null == p2NullItem ? _self._p2NullItem : p2NullItem // ignore: cast_nullable_to_non_nullable
as List<List<String?>>,p2NullAll: freezed == p2NullAll ? _self._p2NullAll : p2NullAll // ignore: cast_nullable_to_non_nullable
as List<dynamic>?,classWithNullableTypesP3: null == classWithNullableTypesP3 ? _self.classWithNullableTypesP3 : classWithNullableTypesP3 // ignore: cast_nullable_to_non_nullable
as ClassWithNullableTypesP3,requiredNullAnyOf: null == requiredNullAnyOf ? _self.requiredNullAnyOf : requiredNullAnyOf // ignore: cast_nullable_to_non_nullable
as String,p1AnyOf: null == p1AnyOf ? _self.p1AnyOf : p1AnyOf // ignore: cast_nullable_to_non_nullable
as String,p2AnyOf: freezed == p2AnyOf ? _self.p2AnyOf : p2AnyOf // ignore: cast_nullable_to_non_nullable
as dynamic,p3AnyOf: freezed == p3AnyOf ? _self.p3AnyOf : p3AnyOf // ignore: cast_nullable_to_non_nullable
as dynamic,p1OneOf: null == p1OneOf ? _self.p1OneOf : p1OneOf // ignore: cast_nullable_to_non_nullable
as String,p2OneOf: freezed == p2OneOf ? _self.p2OneOf : p2OneOf // ignore: cast_nullable_to_non_nullable
as dynamic,p3OneOf: freezed == p3OneOf ? _self.p3OneOf : p3OneOf // ignore: cast_nullable_to_non_nullable
as dynamic,p1AllOf: freezed == p1AllOf ? _self.p1AllOf : p1AllOf // ignore: cast_nullable_to_non_nullable
as dynamic,p2AllOf: freezed == p2AllOf ? _self.p2AllOf : p2AllOf // ignore: cast_nullable_to_non_nullable
as dynamic,p3AllOf: freezed == p3AllOf ? _self.p3AllOf : p3AllOf // ignore: cast_nullable_to_non_nullable
as dynamic,validInt: freezed == validInt ? _self.validInt : validInt // ignore: cast_nullable_to_non_nullable
as int?,validString: freezed == validString ? _self.validString : validString // ignore: cast_nullable_to_non_nullable
as String?,validArray: freezed == validArray ? _self._validArray : validArray // ignore: cast_nullable_to_non_nullable
as List<String>?,p2Null: freezed == p2Null ? _self._p2Null : p2Null // ignore: cast_nullable_to_non_nullable
as List<dynamic>?,p1N: freezed == p1N ? _self.p1N : p1N // ignore: cast_nullable_to_non_nullable
as String?,p2N: freezed == p2N ? _self._p2N : p2N // ignore: cast_nullable_to_non_nullable
as List<String?>?,classWithNullableTypesP3N: freezed == classWithNullableTypesP3N ? _self.classWithNullableTypesP3N : classWithNullableTypesP3N // ignore: cast_nullable_to_non_nullable
as ClassWithNullableTypesP3N?,p1List: freezed == p1List ? _self.p1List : p1List // ignore: cast_nullable_to_non_nullable
as String?,p2List: freezed == p2List ? _self._p2List : p2List // ignore: cast_nullable_to_non_nullable
as List<dynamic>?,p3List: freezed == p3List ? _self.p3List : p3List // ignore: cast_nullable_to_non_nullable
as dynamic,nonNullAnyOf: freezed == nonNullAnyOf ? _self.nonNullAnyOf : nonNullAnyOf // ignore: cast_nullable_to_non_nullable
as ClassWithNullableTypesNonNullAnyOfUnion?,optionalNullAnyOf: freezed == optionalNullAnyOf ? _self.optionalNullAnyOf : optionalNullAnyOf // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

/// Create a copy of ClassWithNullableTypes
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ClassWithNullableTypesP3CopyWith<$Res> get classWithNullableTypesP3 {
  
  return $ClassWithNullableTypesP3CopyWith<$Res>(_self.classWithNullableTypesP3, (value) {
    return _then(_self.copyWith(classWithNullableTypesP3: value));
  });
}/// Create a copy of ClassWithNullableTypes
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ClassWithNullableTypesP3NCopyWith<$Res>? get classWithNullableTypesP3N {
    if (_self.classWithNullableTypesP3N == null) {
    return null;
  }

  return $ClassWithNullableTypesP3NCopyWith<$Res>(_self.classWithNullableTypesP3N!, (value) {
    return _then(_self.copyWith(classWithNullableTypesP3N: value));
  });
}
}

// dart format on
